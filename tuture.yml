name: Django + Nuxt 实现美食分享网站
id: b9b4d831629e9a7df36131b1661569eb
github: 'https://github.com/mRcfps/recipes_app'
created: 2019-10-18T00:00:00.509Z
updated: 2019-10-23T02:52:55.509Z
topics:
  - Python
  - Django
  - Vue
categories:
  - 后端
  - Python
  - 进阶
steps:
  - name: 项目初始化
    commit: c64b3b6
    diff:
      - file: Pipfile
        display: true
        explain:
          pre: 这时 pipenv 便产生了 Pipfile 文件，它的作用就类似 Node 项目中的 package.json 文件：
      - file: api/api/__init__.py
        display: false
      - file: api/api/settings.py
        display: false
      - file: api/api/urls.py
        display: false
      - file: api/api/wsgi.py
        display: false
      - file: api/core/__init__.py
        display: false
      - file: api/core/admin.py
        display: false
      - file: api/core/apps.py
        display: false
      - file: api/core/migrations/__init__.py
        display: false
      - file: api/core/models.py
        display: false
      - file: api/core/tests.py
        display: false
      - file: api/core/views.py
        display: false
      - file: api/manage.py
        display: false
    explain:
      post: >-
        然后用 Django 脚手架创建服务器项目 `api` 的基本结构，并进入到 `api`创建一个子应用 `core`：


        ```bash

        (recipes_app-nV3wuGJ1) $ django-admin startproject api

        (recipes_app-nV3wuGJ1) $ cd api

        (recipes_app-nV3wuGJ1) $ python manage.py startapp core

        ```


        此时项目结构如下所示：


        ```text

        api

        ├── api                      // 项目全局文件目录

        │   ├── __init__.py

        │   ├── settings.py          // 全局配置

        │   ├── urls.py              // 全局路由

        │   └── wsgi.py              // WSGI 服务

        ├── core                     // core 应用目录

        │   ├── __init__.py

        │   ├── admin.py             // 后台管理配置

        │   ├── apps.py

        │   ├── migrations           // 数据库迁移文件目录

        │   │   └── __init__.py

        │   ├── models.py            // 数据模型

        │   ├── tests.py             // 单元测试

        │   ├── urls.py              // 应用路由

        │   └── views.py             // 视图

        └── manage.py                // 项目管理脚本

        ```


        Django
        的默认项目布局如上所示，由一个***全局项目目录***（和项目名称同名，用于存放全局文件）、多个***子应用目录***（每个应用包括数据模型、视图等一整套模块）和一个***项目管理脚本***组成。项目管理脚本的功能包括运行服务器、单元测试、数据库迁移等等。


        让我们运行 Django 服务器，确保一切正常：


        ```bash

        (recipes_app-nV3wuGJ1) $ python manage.py runserver

        ```


        出现以下所示的欢迎界面（Django 2.2版本）：


        ![](tuture-assets/django-welcome.jpg)


        即便现在没有写任何代码，Django 已经悄悄为我们带来了很多酷炫的功能，特别是自带的后台管理系统。首先关闭刚才打开的服务器（Ctrl +
        C），然后进行数据库迁移：


        ```bash

        (recipes_app-nV3wuGJ1) $ python manage.py migrate

        ```


        在这里先简单描述一下数据库迁移（Database Migration）的作用：根据定义好的数据模型，在数据库中创建相应的表格（即 SQL 中的
        `CREATE TABLE ...` 命令）。Django 自身已经定义好了用户、会话等模型，因此需要先进行数据库迁移，在数据库中建表。


        数据库迁移完成后，就可以创建用于登录后台管理的超级用户：


        ```

        (recipes_app-nV3wuGJ1) $ python manage.py createsuperuser

        ```


        按照问题输入信息即可。要记住用户名和密码哦！


        再次打开服务器，访问
        [http://localhost:8000/admin](http://localhost:8000/admin)，可以看到后台管理的登录页面。输入刚才创建的超级用户的用户名和密码，就进入了后台管理系统，如下所示：


        ![](tuture-assets/django-admin.png)


        看上去很简洁专业，但是——没什么东西，而且全是英文！别担心，后面我们会一个个搞定。
      pre: >-
        首先创建项目目录，并进入：


        ```bash

        $ mkdir recipes_app && cd recipes_app

        ```


        在这个项目中，我们用 [pipenv](https://pipenv.kennethreitz.org/) 来管理 Python
        项目的环境依赖。Pipenv 是 Python 社区偶像级大师 Kenneth Reitz
        牵头开发的开发流程优化工具，立志集所有项目管理工具（Node 的 npm、Ruby 的 bundler、PHP 的 composer
        等等）的优势为一体。我们通过下面的命令安装 pipenv，并创建项目的依赖环境：


        ```bash

        $ pip install pipenv

        $ pipenv shell

        ```


        如果看到命令提示符前面出现 `(recipes_app-nV3wuGJ1)`
        的提示（后面那串随机字符串可能不一样），就表明我们已经成功地创建了项目独有的虚拟环境！我们接着安装 Django “三件套”：


        - **Django**: Django 框架本身，提供了丰富且强大的服务器开发组件；

        - **Django Rest Framework**：Django 框架的超级搭档，大大方便了 REST API 的开发；

        - **Django CORS Headers**：用于实现跨域资源请求（CORS）的 Django 中间件（如果你不了解
        CORS，可以参考阮一峰的[日志](http://www.ruanyifeng.com/blog/2016/04/cors.html)）。


        安装命令如下：


        ```bash

        (recipes_app-nV3wuGJ1) $ pipenv install django django-rest-framework
        django-cors-headers

        ```
  - name: 用 Django 实现 REST API
    commit: d4d056f
    diff:
      - file: .editorconfig
        display: false
      - file: .gitignore
      - file: api/api/settings.py
        display: true
        explain:
          pre: >-
            首先，在项目级目录的全局配置文件 settings.py 中做如下改动：


            1. 在 `INSTALLED_APPS` 中添加 `rest_framework`、`corsheaders` 和
            `core`，前两个分别是 Django Rest Framework 和 Django CORS Headers
            的应用，最后一个是我们网站的应用；

            2. 在 `MIDDLEWARE` 中添加
            `corsheaders.middleware.CorsMiddleware`，注册跨域请求中间件（**注意一定要放在最前面！**）;

            3. 设置 `CORS_ORIGIN_WHITELIST`，添加跨域请求白名单，这里我们先写上
            `http://localhost:3000`，后面开发前端时将用到；

            4. 设置 `LANGUAGE_CODE` 为 `zh-hans`，可以将后台管理设置为中文，非常方便；

            5. 设置 `MEDIA_URL` 和 `MEDIA_ROOT`，用于在开发中提供图片资源文件的访问。


            具体代码如下：
      - file: api/core/models.py
        display: true
        explain:
          pre: >-
            接下来就是实现 `core` 这个 Django 应用。实现一个 Django 应用大致都是按照这样的流程：


            1. 定义数据模型（models.py），用于实现和数据库之间的绑定；

            2. 定义后台管理配置（admin.py），用于在后台管理系统中进行操作；

            3. 定义序列化器（serializers.py），*仅当实现 REST API 时需要*，用于提供数据模型的 JSON
            序列化（或其他数据交换格式）；

            4. 定义视图（views.py），用于实现具体的业务逻辑（也许你在第一步就已经开始困惑了，View 不应该代表用户界面吗？实际上，在
            Django 框架中，View 的作用相当于 MVC 框架中的 Controller）；

            5. 定义路由（urls.py），用于定义路由规则，将其映射到相应的视图；

            6. 将应用路由接入全局路由文件（api/urls.py）中。


            我们从第一步开始，完成菜谱 `Recipe` 数据模型如下：
          post: >-
            其中，`class Meta` 定义了 `Recipe` 的元数据；`__str__`
            方法定义了一个菜谱对象转换为字符串时应该怎样显示。这些设置的作用在打开后台管理系统之后就会很清晰了。想要了解更多关于 Django
            数据模型的知识，请参考相关[中文文档](https://docs.djangoproject.com/zh-hans/2.2/topics/db/models/)。
      - file: api/core/admin.py
        display: true
        explain:
          pre: 第二步，为 `core` 子应用配置相应的后台管理功能。非常简单，只需注册定义好的 `Recipe` 模型：
      - file: api/core/serializers.py
        display: true
        explain:
          pre: >-
            第三步，定义序列化器 serializers.py（脚手架并不会自动创建，需要手动创建）。序列化器是 Django Rest
            Framework 提供的功能，能够非常方便地将 Django 数据模型序列化成相应的 JSON 数据格式。在这里，我们定义一个
            `RecipeSerializer`，并在 `class Meta` 中指定对应的数据模型为刚才创建的
            `Recipe`，并选择相应的字段展示：
      - file: api/core/views.py
        display: true
        explain:
          pre: >-
            第四步，实现视图。这里我们采用开挂模式，直接调用 Django Rest Framework
            提供的模型视图集（`ModelViewset`）直接搞定数据模型的增删改查逻辑：
          post: >-
            只需指定 `serializer_class`（序列器类）和
            `queryset`（模型查询集），就自动定义好了模型的添加、删除、查询和修改！虽然视图集非常强大，但是如果要实现更加灵活的业务逻辑，那么还是要为每个接口定义单独的视图类才行。
      - file: api/core/urls.py
        display: true
        explain:
          pre: >-
            第五步，实现路由。由于我们上一步使用了视图集，因此只需先调用 `DefaultRouter`
            自动生成相关的路由，然后加入记录路由映射的列表 `urlpatterns` 中：
          post: |-
            `router` 为我们自动生成以下路由：

            - `/recipes/`：创建食谱（POST 方法）或读取食谱列表（GET方法）；
            - `/recipes/{id}`：获取单个食谱（GET）、更新单个食谱（PUT）或删除食谱（DELETE）。

            注意：**在 Django 路由定义中不包括 HTTP 方法，具体的 HTTP 方法可以在视图中读取并判断**。
      - file: api/api/urls.py
        display: true
        explain:
          pre: 最后一步，我们将 `core` 子应用中的路由接入全局路由：
      - file: api/core/migrations/0001_initial.py
        display: false
      - file: tuture.yml
    explain:
      pre: >-
        接下来我们将实现本项目所需要用的所有 API。对，你没有听错，我们会在这一步实现所有后端接口，大概只 10 分钟左右可以敲完！这就是
        Django 的宣言：


        > The web framework for perfectionists with deadlines.


        “为赶时间的完美主义者而生！”
  - name: 用 Nuxt.js 实现网站首页
    commit: 596203d
    diff:
      - file: client/.editorconfig
        display: false
      - file: client/.gitignore
        display: false
      - file: client/README.md
        display: false
      - file: client/assets/README.md
        display: false
      - file: client/components/Logo.vue
        display: false
      - file: client/components/README.md
        display: false
      - file: client/layouts/README.md
        display: false
      - file: client/layouts/default.vue
        display: false
      - file: client/middleware/README.md
        display: false
      - file: client/nuxt.config.js
        display: false
      - file: client/package.json
        display: false
      - file: client/pages/README.md
        display: false
      - file: client/pages/index.vue
        display: true
        explain:
          pre: 我们在 client/pages 中创建 index.vue 文件，并在其中实现我们的前端首页：
          post: >-
            模板（Template）+ 脚本（Script）+ 样式（Style），经典的 Vue.js 组件。如果对 Vue.js
            还不熟悉的话，建议学习巍哥的 Vue 入门系列教材。
      - file: client/pages/recipes/_id/edit.vue
        display: false
      - file: client/pages/recipes/_id/index.vue
        display: false
      - file: client/pages/recipes/add.vue
        display: false
      - file: client/pages/recipes/index.vue
        display: false
      - file: client/plugins/README.md
        display: false
      - file: client/static/README.md
        display: false
      - file: client/static/favicon.ico
        display: false
      - file: client/static/icon.png
        display: false
      - file: client/static/images/banner.jpg
        display: false
      - file: client/store/README.md
        display: false
      - file: client/yarn.lock
        display: false
      - file: tuture.yml
    explain:
      post: >-
        我们刚刚创建了 pages 目录下的 index.vue 文件，这意味着当访问根路由 `/` 时，这个文件将被访问到。通过 `npm run
        dev`运行我们的前端页面（***记得在 client 子目录下运行！***），可以看到：


        ![](tuture-assets/index-page.jpg)


        真是让人食欲大开！
      pre: >-
        服务器实现完毕之后，就轮到 Nuxt 登场了。我们将把所有的前端代码放到 client 目录中，不过无需自己创建，我们调用 nuxt
        的脚手架来创建前端应用：


        ```bash

        $ npx create-nuxt-app client

        ```


        之后脚手架应用会询问一系列问题，按下面的截图进行选择（当然作者名填自己）：


        ![](tuture-assets/create-nuxt-app.jpg)


        我们对 Nuxt 脚手架生成的目录结构稍作讲解。可以看到 client 目录下有以下子目录：


        - assets：存放图片、CSS、JS 等原始资源文件

        - components：存放 Vue 组件

        - layouts：存放应用布局文件，布局可在多个页面中使用

        - middleware：存放应用的中间件。Nuxt 中的中间件指页面渲染前执行的自定义函数（本教程中不需要）

        - pages：应用的视图和路由。Nuxt 会根据此目录中的 `.vue` 文件自动创建应用的路由

        - plugins: 存放 JavaScript 插件，用于在应用启动前加载（本教程中不需要）

        - static：存放通常不会改变的静态文件，并且将直接映射到路由（即可通过 `/static/picture.png` 访问）

        - store：存放 Vuex Store 文件（本教程中不需要）


        本项目所用到的图片资源请访问我的 [GitHub
        仓库](https://github.com/mRcfps/recipes_app/tree/master/client/static/images)，并下载到对应的目录中。
  - name: 数据展示：实现食谱列表
    commit: 63f7ab0
    diff:
      - file: client/components/RecipeCard.vue
        display: true
        explain:
          pre: 首先，实现将会在多个页面中反复使用的食谱卡片组件 `RecipeCard` 如下：
          post: >-
            在这个组件中，我们定义了两个 `props`，分别是 `recipe`（代表食谱对象）和
            `onDelete`（删除时的回调函数），并在模板中使用这两个成员。
      - file: client/pages/recipes/index.vue
        display: true
        explain:
          pre: "接下来我们将深入体验 Nuxt 的路由功能——通过 pages 目录下的文档结构，就可以自动生成 vue-router 的路由器配置！\n\n例如我们这样安排 pages 下面的目录结构\U0001F447：\n\n```\npages\n├── README.md\n├── index.vue\n└── recipes\n    ├── _id\n    │   ├── edit.vue\n    │   └── index.vue\n    ├── add.vue\n    └── index.vue\n```\n\n`_id` 目录（或者其他以单下划线开头的目录或 .vue 文件）被称作是**动态路由**（Dynamic Routing），可以接受参数作为 URL 的一部分。上面的 pages 目录自动生成下面的 `router`：\n\n```js\nrouter: {\n  routes: [\n    {\n      name: 'index',\n      path: '/',\n      component: 'pages/index.vue'\n    },\n    {\n      name: 'recipes',\n      path: '/recipes',\n      component: 'pages/recipes/index.vue'\n    },\n    {\n      name: 'recipes-add',\n      path: '/recipes/add',\n      component: 'pages/recipes/add.vue'\n    },\n    {\n      name: 'recipes-id',\n      path: '/recipes/:id?',\n      component: 'pages/recipes/_id/index.vue'\n    },\n    {\n      name: 'recipes-id-edit',\n      path: '/recipes/:id?/edit',\n      component: 'pages/recipes/_id/edit.vue'\n    }\n  ]\n}\n```\n\n如果想要更深入地了解 Nuxt 的路由功能，请参考[官方文档](https://nuxtjs.org/guide/routing)。\n\n创建食谱列表页面 pages/recipes/index.vue（先使用假数据填充），代码如下："
          post: ''
      - file: client/static/images/food-1.jpeg
        display: false
      - file: client/static/images/food-2.jpeg
        display: false
      - file: tuture.yml
    explain:
      pre: 接下来我们将演示如何展示数据，并实现食谱列表页面。
      post: |-
        打开前端网站，可以看到我们刚才实现的食谱列表页面：

        ![](tuture-assets/recipe-list-fake.jpg)
  - name: 从服务器获取数据
    commit: 60a60d7
    diff:
      - file: api/api/urls.py
        display: true
        explain:
          pre: 首先我们要配置一下 Django 服务器，使前端能够访问其静态文件。调整 api/api/urls 文件如下：
          post: >-
            需要注意的是，这样配置静态文件路由仅应当在开发环境下使用。在生产环境下（settings.py 中的 `DEBUG` 设为
            `False` 时），静态文件路由将自动生效（因为 Django 并不适合作为静态文件服务器，应该选用类似 Nginx
            之类的服务器，在后续教程中我们将更深入地讨论）。
      - file: client/nuxt.config.js
        display: true
        explain:
          pre: >-
            在客户端，我们先要对 Nuxt 进行全局配置。Nuxt 包括
            [axios](https://github.com/axios/axios) 包，这是一个非常出色的基于 Promise 的 HTTP
            请求库。在 nuxt.config.js 中的 `axios` 一项中添加 Django 服务器的 URL：
      - file: client/pages/recipes/index.vue
        display: true
        explain:
          pre: >-
            将食谱列表页面中暂时填充的假数据删去，通过 `asyncData` 方法获取数据。由于我们之前配置好了 axios，所以
            `asyncData` 函数可以获取到 `$axios` 对象用于发起 HTTP 请求。我们实现页面加载的数据获取以及
            `deleteRecipe` 事件，代码如下：
      - file: client/pages/recipes/_id/index.vue
        display: true
        explain:
          pre: 我们进一步实现食谱详情页面。在 pages/recipes 目录中创建 _id 目录，在其中添加 index.vue 文件，代码如下：
    explain:
      pre: 在这一步中，我们将打通前后端——前端将从后端获取数据。
      post: >-
        为了测试前端页面能否真正从后端获取数据，我们先要在后端数据库中添加一些数据，而这对 Django 来说就非常方便了。进入 api 目录，运行
        `python manage.py runserver`
        打开服务器，然后进入后台管理页面（[http://localhost:8000/admin](http://localhost:8000/admin)），添加一些数据：


        ![](tuture-assets/add-data-in-admin.jpg)


        再运行前端页面，可以看到我们刚刚在 Django 后台管理中添加的项目：


        ![](tuture-assets/recipe-list.jpg)
  - name: 实现食谱的详情和添加页面
    commit: 5f1edd9
    diff:
      - file: client/pages/recipes/_id/edit.vue
        display: true
        explain:
          post: |-
            实现之后的页面如下：

            ![](tuture-assets/recipe-detail.jpg)
      - file: client/pages/recipes/add.vue
        display: true
        explain:
          post: |-
            实现的页面如下：

            ![](tuture-assets/add-recipe.jpg)
      - file: client/static/images/placeholder.png
        display: false
    explain:
      pre: >-
        有了前面的铺垫，实现食谱的添加和删除也基本上是按部就班了。我们在 pages/recipes/_id 中分别实现
        `edit.vue`（食谱详情页面） 和 `add.vue` （创建食谱页面）如下。
  - name: 一点强迫症：全局页面跳转效果
    commit: 04edf4c
    diff:
      - file: client/assets/css/transition.css
        display: true
        explain:
          pre: 首先在 assets 目录中创建 css 目录，并在其中添加 transition.css 文件，代码如下：
      - file: client/nuxt.config.js
        display: true
        explain:
          pre: 在 Nuxt 配置文件中将刚才写的 transition.css 中添加到全局 CSS 中：
      - file: tuture.yml
    explain:
      pre: 在这一节中，我们将演示如何在 Nuxt 中添加全局样式文件，来实现前端页面之间的跳转效果。
      post: 至此，一个具有完整增删改查功能、实现了的前后端分离的食谱网站就完成了！
description: >-
  Django 作为 Python 社区最受欢迎的 Web 框架之一，凭借其高度抽象的组件和强大方便的脚手架，将快速且流畅的开发体验演绎到了极致。而 Nuxt
  作为从 Vue.js 进化而来的前端框架，能够轻松胜任复杂的 SPA（单页应用）开发。两者相遇，能够擦出怎样的火花？这篇教程将用 Django + Nuxt
  实现带有完整的增删改查（CRUD）功能的前后端应用。最后郑重警告：不要在深夜阅读此教程！！！
